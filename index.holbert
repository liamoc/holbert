[{"tag":"Heading","contents":[0,"Holbert Demo"]},{"tag":"Paragraph","contents":"Welcome to this demo of the Holbert prototype. Holbert is the combination of an online notebook and theorem prover. It allows for preparation of interactive documents which include proof exercises in natural deduction. \n"},{"tag":"Rule","contents":["Transitivity",[["A","B","C"],[[[],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_=_"},{"tag":"LocalVar","contents":2}]},{"tag":"LocalVar","contents":1}]}],[[],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_=_"},{"tag":"LocalVar","contents":1}]},{"tag":"LocalVar","contents":0}]}]],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_=_"},{"tag":"LocalVar","contents":2}]},{"tag":"LocalVar","contents":0}]}],null]},{"tag":"Rule","contents":["testtransitivity",[[],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_=_"},{"tag":"Const","contents":"A"}]},{"tag":"Const","contents":"D"}]}],[[null,[],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_=_"},{"tag":"Const","contents":"A"}]},{"tag":"Const","contents":"D"}]},[{"tag":"Transitivity","contents":null},[[null,[],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_=_"},{"tag":"Const","contents":"A"}]},{"tag":"MetaVar","contents":7}]},[{"tag":"Transitivity","contents":null},[[null,[],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_=_"},{"tag":"Const","contents":"A"}]},{"tag":"MetaVar","contents":13}]},null],[null,[],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_=_"},{"tag":"MetaVar","contents":13}]},{"tag":"MetaVar","contents":7}]},null]]]],[null,[],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_=_"},{"tag":"MetaVar","contents":7}]},{"tag":"Const","contents":"D"}]},[{"tag":"Transitivity","contents":null},[[null,[],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_=_"},{"tag":"MetaVar","contents":7}]},{"tag":"MetaVar","contents":10}]},null],[null,[],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_=_"},{"tag":"MetaVar","contents":10}]},{"tag":"Const","contents":"D"}]},null]]]]]]],15]]},{"tag":"Heading","contents":[1,"Design Philosophy"]},{"tag":"Paragraph","contents":"I designed Holbert to be an educational tool. Ultimately, I plan to convert the notes from the Programming Languages course I taught for many years into this tool. Previous attempts to integrate theorem provers with PL foundations education have been quite successful (see /Software Foundations/, /Concrete Semantics/), but I feel that the complexity of tools such as Coq and Isabelle mean that their respective courses become less about PL foundations in general and more about how to operate the theorem prover effectively. People using these PL foundations books to learn how to use their proof assistants rather than to learn PL foundations is evidence of this. \n"},{"tag":"Paragraph","contents":"In addition, conventional proof assistants are large pieces of software that can be complicated to install. By making Holbert run in the browser, students don't have to install anything, and can even use a tablet or other device to access work.\n"},{"tag":"Paragraph","contents":"Holbert is both a document preparation system and a proof assistant. This way, proof problems and sets of rules and exercises can be embedded right within educational notes. In future, I want to extend this system to support examinations and assessments as well.\n"},{"tag":"Paragraph","contents":"Holbert is based on /natural deduction/ and /higher order logic/. Because it doesn't have a type system, this means the logic it encodes is *unsound*. So it should not be used to verify production software or anywhere where the theorems it proves should be trusted. Normally, I would be very opposed to removing type systems from anything, however removing the type system from higher order logic simplifies its pedagogy, particularly when teaching a course about type systems. If I used a typed theorem prover, in order to teach about types, I would first have to teach about types, which is an annoying circularity.\n"},{"tag":"Heading","contents":[1,"Propositional Logic"]},{"tag":"Paragraph","contents":"To give an example of Holbert in action, lets define basic propositional logic. All terms are given in untyped lambda calculus. Terms applied to constants with underscores in them are rendered as infix operators. For example, ~if_then_else_fi A B C~ is rendered as $A B C:if_then_else_fi A B C$. Many common operators and symbols have their ASCII approximations replaced with unicode, and trailing numbers are rendered as subscripts.\n"},{"tag":"Rule","contents":["/\\ I",[["A","B"],[[[],[],{"tag":"LocalVar","contents":1}],[[],[],{"tag":"LocalVar","contents":0}]],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_/\\_"},{"tag":"LocalVar","contents":1}]},{"tag":"LocalVar","contents":0}]}],null]},{"tag":"Rule","contents":["/\\ E1",[["A","B"],[[[],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_/\\_"},{"tag":"LocalVar","contents":1}]},{"tag":"LocalVar","contents":0}]}]],{"tag":"LocalVar","contents":1}],null]},{"tag":"Rule","contents":["/\\ E2",[["A","B"],[[[],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_/\\_"},{"tag":"LocalVar","contents":1}]},{"tag":"LocalVar","contents":0}]}]],{"tag":"LocalVar","contents":0}],null]},{"tag":"Paragraph","contents":"The implication rules give an example of a hypothetical derivation (i.e. a rule with a rule as a premise):\n"},{"tag":"Rule","contents":["-> I",[["A","B"],[[[],[[[],[],{"tag":"LocalVar","contents":1}]],{"tag":"LocalVar","contents":0}]],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_->_"},{"tag":"LocalVar","contents":1}]},{"tag":"LocalVar","contents":0}]}],null]},{"tag":"Rule","contents":["-> E",[["A","B"],[[[],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_->_"},{"tag":"LocalVar","contents":1}]},{"tag":"LocalVar","contents":0}]}],[[],[],{"tag":"LocalVar","contents":1}]],{"tag":"LocalVar","contents":0}],null]},{"tag":"Paragraph","contents":"The \"Display Options\" in the bottom section of the sidebar provides a few options for rendering these rules. By default, we use the \"Hybrid\" mode which uses linear notation for premises and vertical notation for the main inference vinculum. Vertical notation is closer to Gentzen's original notation for natural deduction.\n"},{"tag":"Paragraph","contents":"The rules are editable. Click any part of the rule to edit it. To add premises, first click on the conclusion to which you want to add a premise. Similarly for meta-binders.\n"},{"tag":"Paragraph","contents":"/Note/: Altering rules will delete any part of a proof that makes use of the rule, to ensure that theorems remain in a consistent state. Be careful of this!\n"},{"tag":"Paragraph","contents":"To add new rules (or indeed any other element), click on a plus sign icon on the right hand side of the main content panel, then click \"Axiom\".\n"},{"tag":"Heading","contents":[2,"Proofs"]},{"tag":"Paragraph","contents":"Proofs are constructed \"backwards\", in the bottom-up fashion working from the conclusion. Clicking on a goal tag on the proof tree for a Theorem gives a list of all available facts. Click on any such fact to apply it as an introduction rule. Only pattern unification is used. In the future, I plan to allow \"unsolved constraint\" steps where unification problems can be delayed, which will give more flexibility in working with proofs. I also plan to allow the user to explicitly instantiate metavariables in future.\n"},{"tag":"Paragraph","contents":"The first proof here (commutativity of conjunction) is partially complete already, whereas associativity has not been started:\n"},{"tag":"Rule","contents":["/\\ comm",[["A","B"],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_->_"},{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_/\\_"},{"tag":"LocalVar","contents":1}]},{"tag":"LocalVar","contents":0}]}]},{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_/\\_"},{"tag":"LocalVar","contents":0}]},{"tag":"LocalVar","contents":1}]}]}],[[null,["A","B"],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_->_"},{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_/\\_"},{"tag":"LocalVar","contents":1}]},{"tag":"LocalVar","contents":0}]}]},{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_/\\_"},{"tag":"LocalVar","contents":0}]},{"tag":"LocalVar","contents":1}]}]},[{"tag":"Defn","contents":"-> I"},[[null,[],[[[],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_/\\_"},{"tag":"LocalVar","contents":1}]},{"tag":"LocalVar","contents":0}]}]],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_/\\_"},{"tag":"LocalVar","contents":0}]},{"tag":"LocalVar","contents":1}]},[{"tag":"Defn","contents":"/\\ I"},[[null,[],[],{"tag":"LocalVar","contents":0},[{"tag":"Defn","contents":"/\\ E2"},[[null,[],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_/\\_"},{"tag":"LocalVar","contents":1}]},{"tag":"LocalVar","contents":0}]},[{"tag":"Local","contents":0},[]]]]]],[null,[],[],{"tag":"LocalVar","contents":1},null]]]]]]],6]]},{"tag":"Rule","contents":["/\\ assoc",[["A","B","C"],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_->_"},{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_/\\_"},{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_/\\_"},{"tag":"LocalVar","contents":2}]},{"tag":"LocalVar","contents":1}]}]},{"tag":"LocalVar","contents":0}]}]},{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_/\\_"},{"tag":"LocalVar","contents":2}]},{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_/\\_"},{"tag":"LocalVar","contents":1}]},{"tag":"LocalVar","contents":0}]}]}]}],[[null,["A","B","C"],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_->_"},{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_/\\_"},{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_/\\_"},{"tag":"LocalVar","contents":2}]},{"tag":"LocalVar","contents":1}]}]},{"tag":"LocalVar","contents":0}]}]},{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_/\\_"},{"tag":"LocalVar","contents":2}]},{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_/\\_"},{"tag":"LocalVar","contents":1}]},{"tag":"LocalVar","contents":0}]}]}]},null],0]]},{"tag":"Heading","contents":[2,"Disjunction and Negation"]},{"tag":"Paragraph","contents":"We haven't yet specified all the remaining bits of propositional logic, so let's quickly do that now:\n"},{"tag":"Rule","contents":["\\/ I1",[["A","B"],[[[],[],{"tag":"LocalVar","contents":1}]],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_\\/_"},{"tag":"LocalVar","contents":1}]},{"tag":"LocalVar","contents":0}]}],null]},{"tag":"Rule","contents":["\\/ I2",[["A","B"],[[[],[],{"tag":"LocalVar","contents":0}]],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_\\/_"},{"tag":"LocalVar","contents":1}]},{"tag":"LocalVar","contents":0}]}],null]},{"tag":"Rule","contents":["\\/ E",[["A","B","C"],[[[],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_\\/_"},{"tag":"LocalVar","contents":2}]},{"tag":"LocalVar","contents":1}]}],[[],[[[],[],{"tag":"LocalVar","contents":2}]],{"tag":"LocalVar","contents":0}],[[],[[[],[],{"tag":"LocalVar","contents":1}]],{"tag":"LocalVar","contents":0}]],{"tag":"LocalVar","contents":0}],null]},{"tag":"Paragraph","contents":"We will specify negation $A: not A$ as merely equivalent to $A: _->_ A bot$, with the same introduction and elimination rules as implication:\n"},{"tag":"Rule","contents":["not I",[["A"],[[[],[[[],[],{"tag":"LocalVar","contents":0}]],{"tag":"Const","contents":"bot"}]],{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"LocalVar","contents":0}]}],null]},{"tag":"Rule","contents":["not E",[["A"],[[[],[],{"tag":"LocalVar","contents":0}],[[],[],{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"LocalVar","contents":0}]}]],{"tag":"Const","contents":"bot"}],null]},{"tag":"Paragraph","contents":"Lastly, the rules to define the constants for true $top$ and false $bot$, where true has only an introduction rule and false has only an elimination rule."},{"tag":"Rule","contents":["top I",[[],[],{"tag":"Const","contents":"top"}],null]},{"tag":"Rule","contents":["bot E",[["P"],[[[],[],{"tag":"Const","contents":"bot"}]],{"tag":"LocalVar","contents":0}],null]},{"tag":"Heading","contents":[3,"Constructivity"]},{"tag":"Paragraph","contents":"The logic we have formalised here is constructive. We can prove only double negation introduction:\n"},{"tag":"Rule","contents":["not not I",[["P"],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_->_"},{"tag":"LocalVar","contents":0}]},{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"LocalVar","contents":0}]}]}]}],[[null,["P"],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_->_"},{"tag":"LocalVar","contents":0}]},{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"LocalVar","contents":0}]}]}]},[{"tag":"Defn","contents":"-> I"},[[null,[],[[[],[],{"tag":"LocalVar","contents":0}]],{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"LocalVar","contents":0}]}]},[{"tag":"Defn","contents":"not I"},[[null,[],[[[],[],{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"LocalVar","contents":0}]}]],{"tag":"Const","contents":"bot"},[{"tag":"Defn","contents":"not E"},[[null,[],[],{"tag":"LocalVar","contents":0},[{"tag":"Local","contents":0},[]]],[null,[],[],{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"LocalVar","contents":0}]},[{"tag":"Local","contents":1},[]]]]]]]]]]]],4]]},{"tag":"Paragraph","contents":"To experiment with the above proof, you can press the trash can next to any rule application to reconstruct the proof from that point.\n"},{"tag":"Rule","contents":["not not E",[["P"],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_->_"},{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"LocalVar","contents":0}]}]}]},{"tag":"LocalVar","contents":0}]}],[[null,["P"],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_->_"},{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"LocalVar","contents":0}]}]}]},{"tag":"LocalVar","contents":0}]},null],0]]},{"tag":"Paragraph","contents":"The rules we have aren't enough to express this classical logic principle.\n"},{"tag":"Heading","contents":[1,"Higher Order Logic"]},{"tag":"Paragraph","contents":"As Holbert terms are $lambda$ terms, we can use $lambda$-abstractions to encode variable binding structure, and avoid ugliness such as substitution. These $lambda$ abstractions are defined without much ceremony in Holbert, where $P: x. P x$ (written as ~x. P x~) is a $lambda$ term with a parameter $x$ and a result $P: P x$.\n"},{"tag":"Rule","contents":["all I",[["P"],[[["x"],[],{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]}]],{"tag":"Ap","contents":[{"tag":"Const","contents":"all"},{"tag":"Lam","contents":["x",{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]}]}]}],null]},{"tag":"Rule","contents":["spec",[["P","x"],[[[],[],{"tag":"Ap","contents":[{"tag":"Const","contents":"all"},{"tag":"Lam","contents":["x",{"tag":"Ap","contents":[{"tag":"LocalVar","contents":2},{"tag":"LocalVar","contents":0}]}]}]}]],{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]}],null]},{"tag":"Paragraph","contents":"The above rule $spec$ might be considered an elimination rule for the $all$ quantifier, but the two metavariables in the one application do not play well with our unification algorithm (or indeed, any unification algorithm). Therefore, it's often more useful to have a slightly less direct elimination rule:\n"},{"tag":"Rule","contents":["all E",[["P","R"],[[[],[],{"tag":"Ap","contents":[{"tag":"Const","contents":"all"},{"tag":"Lam","contents":["x",{"tag":"Ap","contents":[{"tag":"LocalVar","contents":2},{"tag":"LocalVar","contents":0}]}]}]}],[[],[[["x"],[],{"tag":"Ap","contents":[{"tag":"LocalVar","contents":2},{"tag":"LocalVar","contents":0}]}]],{"tag":"LocalVar","contents":0}]],{"tag":"LocalVar","contents":0}],null]},{"tag":"Paragraph","contents":"The existential quantifier is the dual of the universal, and the rules are using a similar format:\n"},{"tag":"Rule","contents":["exists I",[["P","x"],[[[],[],{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]}]],{"tag":"Ap","contents":[{"tag":"Const","contents":"exists"},{"tag":"Lam","contents":["x",{"tag":"Ap","contents":[{"tag":"LocalVar","contents":2},{"tag":"LocalVar","contents":0}]}]}]}],null]},{"tag":"Rule","contents":["exists E",[["P","R"],[[[],[],{"tag":"Ap","contents":[{"tag":"Const","contents":"exists"},{"tag":"Lam","contents":["x",{"tag":"Ap","contents":[{"tag":"LocalVar","contents":2},{"tag":"LocalVar","contents":0}]}]}]}],[["x"],[[[],[],{"tag":"Ap","contents":[{"tag":"LocalVar","contents":2},{"tag":"LocalVar","contents":0}]}]],{"tag":"LocalVar","contents":1}]],{"tag":"LocalVar","contents":0}],null]},{"tag":"Paragraph","contents":"As we are still in a constructive logic, we can prove only one direction of the classical equivalence between $P: exists (x. not (P x))$ and $P: not (all (x. P x))$.\n"},{"tag":"Rule","contents":["deMorgan1",[["P"],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_->_"},{"tag":"Ap","contents":[{"tag":"Const","contents":"exists"},{"tag":"Lam","contents":["x",{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]}]}]}]}]},{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"Ap","contents":[{"tag":"Const","contents":"all"},{"tag":"Lam","contents":["x",{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]}]}]}]}]}],[[null,["P"],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_->_"},{"tag":"Ap","contents":[{"tag":"Const","contents":"exists"},{"tag":"Lam","contents":["x",{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]}]}]}]}]},{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"Ap","contents":[{"tag":"Const","contents":"all"},{"tag":"Lam","contents":["x",{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]}]}]}]}]},[{"tag":"Defn","contents":"-> I"},[[null,[],[[[],[],{"tag":"Ap","contents":[{"tag":"Const","contents":"exists"},{"tag":"Lam","contents":["x",{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]}]}]}]}]],{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"Ap","contents":[{"tag":"Const","contents":"all"},{"tag":"Lam","contents":["x",{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]}]}]}]},[{"tag":"Defn","contents":"not I"},[[null,[],[[[],[],{"tag":"Ap","contents":[{"tag":"Const","contents":"all"},{"tag":"Lam","contents":["x",{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]}]}]}]],{"tag":"Const","contents":"bot"},[{"tag":"Defn","contents":"exists E"},[[null,[],[],{"tag":"Ap","contents":[{"tag":"Const","contents":"exists"},{"tag":"Lam","contents":["x",{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]}]}]}]},[{"tag":"Local","contents":0},[]]],[null,["x"],[[[],[],{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]}]}]],{"tag":"Const","contents":"bot"},[{"tag":"Defn","contents":"all E"},[[null,[],[],{"tag":"Ap","contents":[{"tag":"Const","contents":"all"},{"tag":"Lam","contents":["x",{"tag":"Ap","contents":[{"tag":"LocalVar","contents":2},{"tag":"LocalVar","contents":0}]}]}]},[{"tag":"Local","contents":1},[]]],[null,[],[[["x"],[],{"tag":"Ap","contents":[{"tag":"LocalVar","contents":2},{"tag":"LocalVar","contents":0}]}]],{"tag":"Const","contents":"bot"},[{"tag":"Defn","contents":"not E"},[[null,[],[],{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]},[{"tag":"Local","contents":3},[]]],[null,[],[],{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]}]},[{"tag":"Local","contents":2},[]]]]]]]]]]]]]]]]]],10]]},{"tag":"Paragraph","contents":"In the other direction, we do get almost to a complete proof, and at first glance it looks as though we could unify the metavariable with $x: x$ to complete the proof:\n"},{"tag":"Rule","contents":["deMorgan2",[["P"],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_->_"},{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"Ap","contents":[{"tag":"Const","contents":"all"},{"tag":"Lam","contents":["x",{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]}]}]}]}]},{"tag":"Ap","contents":[{"tag":"Const","contents":"exists"},{"tag":"Lam","contents":["x",{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]}]}]}]}]}],[[null,["P"],[],{"tag":"Ap","contents":[{"tag":"Ap","contents":[{"tag":"Const","contents":"_->_"},{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"Ap","contents":[{"tag":"Const","contents":"all"},{"tag":"Lam","contents":["x",{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]}]}]}]}]},{"tag":"Ap","contents":[{"tag":"Const","contents":"exists"},{"tag":"Lam","contents":["x",{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]}]}]}]}]},[{"tag":"Defn","contents":"-> I"},[[null,[],[[[],[],{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"Ap","contents":[{"tag":"Const","contents":"all"},{"tag":"Lam","contents":["x",{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]}]}]}]}]],{"tag":"Ap","contents":[{"tag":"Const","contents":"exists"},{"tag":"Lam","contents":["x",{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]}]}]}]},[{"tag":"Defn","contents":"exists I"},[[null,[],[],{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"Ap","contents":[{"tag":"LocalVar","contents":0},{"tag":"Ap","contents":[{"tag":"MetaVar","contents":14},{"tag":"LocalVar","contents":0}]}]}]},[{"tag":"Defn","contents":"not I"},[[null,[],[[[],[],{"tag":"Ap","contents":[{"tag":"LocalVar","contents":0},{"tag":"Ap","contents":[{"tag":"MetaVar","contents":14},{"tag":"LocalVar","contents":0}]}]}]],{"tag":"Const","contents":"bot"},[{"tag":"Defn","contents":"not E"},[[null,[],[],{"tag":"Ap","contents":[{"tag":"Const","contents":"all"},{"tag":"Lam","contents":["x",{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]}]}]},[{"tag":"Defn","contents":"all I"},[[null,["x"],[],{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]},null]]]],[null,[],[],{"tag":"Ap","contents":[{"tag":"Const","contents":"not"},{"tag":"Ap","contents":[{"tag":"Const","contents":"all"},{"tag":"Lam","contents":["x",{"tag":"Ap","contents":[{"tag":"LocalVar","contents":1},{"tag":"LocalVar","contents":0}]}]}]}]},[{"tag":"Local","contents":0},[]]]]]]]]]]]]]]],17]]},{"tag":"Paragraph","contents":"The reason this doesn't work becomes clearer if we show metavariable telescopes (the option in the sidebar). The variable $x: x$ does not occur in the telescope, and thus this metavariable cannot be unified with $x : x$.\n"}]